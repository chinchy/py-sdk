# coding: utf-8

"""
    Fireblocks API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)  # noqa: E501

    The version of the OpenAPI document: 1.6.2
    Contact: support@fireblocks.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


import re  # noqa: F401
from typing_extensions import Annotated
from pydantic import Field, StrictBool, StrictFloat, StrictStr, confloat, conint, constr

from typing import Any, Dict, List, Optional

from fireblocks_client.models.create_address_response import CreateAddressResponse
from fireblocks_client.models.create_vault_account_asset_address_request import CreateVaultAccountAssetAddressRequest
from fireblocks_client.models.create_vault_account_asset_request import CreateVaultAccountAssetRequest
from fireblocks_client.models.create_vault_account_request import CreateVaultAccountRequest
from fireblocks_client.models.create_vault_asset_response import CreateVaultAssetResponse
from fireblocks_client.models.paginated_asset_wallet_response import PaginatedAssetWalletResponse
from fireblocks_client.models.public_key_information import PublicKeyInformation
from fireblocks_client.models.set_auto_fuel_for_vault_account_request import SetAutoFuelForVaultAccountRequest
from fireblocks_client.models.set_customer_ref_id_for_vault_account_request import SetCustomerRefIdForVaultAccountRequest
from fireblocks_client.models.unspent_inputs_response import UnspentInputsResponse
from fireblocks_client.models.update_vault_account_asset_address_request import UpdateVaultAccountAssetAddressRequest
from fireblocks_client.models.update_vault_account_request import UpdateVaultAccountRequest
from fireblocks_client.models.vault_account import VaultAccount
from fireblocks_client.models.vault_accounts_paged_response import VaultAccountsPagedResponse
from fireblocks_client.models.vault_asset import VaultAsset
from fireblocks_client.models.vault_wallet_address import VaultWalletAddress
from fireblocks_client.api_client import ApiClient
from fireblocks_client.api_client import Configuration
from fireblocks_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)
from pydantic import validate_arguments,validate_call

class VaultsApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, configuration:Configuration = None):
        if configuration is None:
            api_client = ApiClient()
        else:
            api_client = ApiClient(configuration)
        self.api_client = api_client

    @validate_call
    def activate_asset_for_vault_account(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to return, or 'default' for the default vault account")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], **kwargs) -> CreateVaultAssetResponse:  # noqa: E501
        """Activate a wallet in a vault account  # noqa: E501

        Initiates activation for a wallet in a vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.activate_asset_for_vault_account(vault_account_id, asset_id, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to return, or 'default' for the default vault account (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateVaultAssetResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.activate_asset_for_vault_account_with_http_info(vault_account_id, asset_id, **kwargs)  # noqa: E501

    @validate_call
    def activate_asset_for_vault_account_with_http_info(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to return, or 'default' for the default vault account")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], **kwargs):  # noqa: E501
        """Activate a wallet in a vault account  # noqa: E501

        Initiates activation for a wallet in a vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.activate_asset_for_vault_account_with_http_info(vault_account_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to return, or 'default' for the default vault account (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateVaultAssetResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'vault_account_id',
            'asset_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method activate_asset_for_vault_account" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']

        if _params['asset_id']:
            _path_params['assetId'] = _params['asset_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "CreateVaultAssetResponse",
        }

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/{assetId}/activate', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def create_legacy_address_for_vault_account_asset(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], address_id : Annotated[StrictStr, Field(..., description="The segwit address to translate")], **kwargs) -> CreateAddressResponse:  # noqa: E501
        """Convert a segwit address to legacy format  # noqa: E501

        Converts an existing segwit address to the legacy format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_legacy_address_for_vault_account_asset(vault_account_id, asset_id, address_id, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param address_id: The segwit address to translate (required)
        :type address_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateAddressResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.create_legacy_address_for_vault_account_asset_with_http_info(vault_account_id, asset_id, address_id, **kwargs)  # noqa: E501

    @validate_call
    def create_legacy_address_for_vault_account_asset_with_http_info(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], address_id : Annotated[StrictStr, Field(..., description="The segwit address to translate")], **kwargs):  # noqa: E501
        """Convert a segwit address to legacy format  # noqa: E501

        Converts an existing segwit address to the legacy format.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.create_legacy_address_for_vault_account_asset_with_http_info(vault_account_id, asset_id, address_id, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param address_id: The segwit address to translate (required)
        :type address_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateAddressResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'vault_account_id',
            'asset_id',
            'address_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_legacy_address_for_vault_account_asset" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']

        if _params['asset_id']:
            _path_params['assetId'] = _params['asset_id']

        if _params['address_id']:
            _path_params['addressId'] = _params['address_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "CreateAddressResponse",
        }

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/create_legacy', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def create_vault_account(self, create_vault_account_request : CreateVaultAccountRequest, **kwargs) -> VaultAccount:  # noqa: E501
        """Create a new vault account  # noqa: E501

        Creates a new vault account with the requested name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_vault_account(create_vault_account_request, async_req = True)
        >>> result = thread.get()

        :param create_vault_account_request: (required)
        :type create_vault_account_request: CreateVaultAccountRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: VaultAccount
        """
        kwargs['_return_http_data_only'] = True
        return self.create_vault_account_with_http_info(create_vault_account_request, **kwargs)  # noqa: E501

    @validate_call
    def create_vault_account_with_http_info(self, create_vault_account_request : CreateVaultAccountRequest, **kwargs):  # noqa: E501
        """Create a new vault account  # noqa: E501

        Creates a new vault account with the requested name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.create_vault_account_with_http_info(create_vault_account_request, async_req=True)
        >>> result = thread.get()

        :param create_vault_account_request: (required)
        :type create_vault_account_request: CreateVaultAccountRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(VaultAccount, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'create_vault_account_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_vault_account" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_vault_account_request']:
            _body_params = _params['create_vault_account_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*', 'application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "VaultAccount",
        }

        return self.api_client.call_api(
            '/vault/accounts', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def create_vault_account_asset(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to return, or 'default' for the default vault account")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], create_vault_account_asset_request : Optional[CreateVaultAccountAssetRequest] = None, **kwargs) -> CreateVaultAssetResponse:  # noqa: E501
        """Create a new wallet  # noqa: E501

        Creates a wallet for a specific asset in a vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_vault_account_asset(vault_account_id, asset_id, create_vault_account_asset_request, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to return, or 'default' for the default vault account (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param create_vault_account_asset_request:
        :type create_vault_account_asset_request: CreateVaultAccountAssetRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateVaultAssetResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.create_vault_account_asset_with_http_info(vault_account_id, asset_id, create_vault_account_asset_request, **kwargs)  # noqa: E501

    @validate_call
    def create_vault_account_asset_with_http_info(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to return, or 'default' for the default vault account")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], create_vault_account_asset_request : Optional[CreateVaultAccountAssetRequest] = None, **kwargs):  # noqa: E501
        """Create a new wallet  # noqa: E501

        Creates a wallet for a specific asset in a vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.create_vault_account_asset_with_http_info(vault_account_id, asset_id, create_vault_account_asset_request, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to return, or 'default' for the default vault account (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param create_vault_account_asset_request:
        :type create_vault_account_asset_request: CreateVaultAccountAssetRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateVaultAssetResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'vault_account_id',
            'asset_id',
            'create_vault_account_asset_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_vault_account_asset" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']

        if _params['asset_id']:
            _path_params['assetId'] = _params['asset_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_vault_account_asset_request']:
            _body_params = _params['create_vault_account_asset_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*', 'application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "CreateVaultAssetResponse",
        }

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/{assetId}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def create_vault_account_asset_address(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to return")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], create_vault_account_asset_address_request : Optional[CreateVaultAccountAssetAddressRequest] = None, **kwargs) -> CreateAddressResponse:  # noqa: E501
        """Create new asset deposit address  # noqa: E501

        Creates a new deposit address for an asset of a vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_vault_account_asset_address(vault_account_id, asset_id, create_vault_account_asset_address_request, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to return (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param create_vault_account_asset_address_request:
        :type create_vault_account_asset_address_request: CreateVaultAccountAssetAddressRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: CreateAddressResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.create_vault_account_asset_address_with_http_info(vault_account_id, asset_id, create_vault_account_asset_address_request, **kwargs)  # noqa: E501

    @validate_call
    def create_vault_account_asset_address_with_http_info(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to return")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], create_vault_account_asset_address_request : Optional[CreateVaultAccountAssetAddressRequest] = None, **kwargs):  # noqa: E501
        """Create new asset deposit address  # noqa: E501

        Creates a new deposit address for an asset of a vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.create_vault_account_asset_address_with_http_info(vault_account_id, asset_id, create_vault_account_asset_address_request, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to return (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param create_vault_account_asset_address_request:
        :type create_vault_account_asset_address_request: CreateVaultAccountAssetAddressRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(CreateAddressResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'vault_account_id',
            'asset_id',
            'create_vault_account_asset_address_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_vault_account_asset_address" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']

        if _params['asset_id']:
            _path_params['assetId'] = _params['asset_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['create_vault_account_asset_address_request']:
            _body_params = _params['create_vault_account_asset_address_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*', 'application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "CreateAddressResponse",
        }

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/{assetId}/addresses', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def get_asset_wallets(self, total_amount_larger_than : Annotated[Optional[StrictFloat], Field(description="When specified, only asset wallets with total balance larger than this amount are returned.")] = None, asset_id : Annotated[Optional[StrictStr], Field(description="When specified, only asset wallets cross vault accounts that have this asset ID are returned.")] = None, before : Annotated[Optional[StrictStr], Field(description="Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page.")] = None, after : Annotated[Optional[StrictStr], Field(description="Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page.")] = None, limit : Annotated[Optional[confloat(ge=1000, le=1, strict=True)], Field(description="The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000.")] = None, **kwargs) -> PaginatedAssetWalletResponse:  # noqa: E501
        """List asset wallets (Paginated)  # noqa: E501

        Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances. **Note:**   - This API endpoint is in limited availability and available for selected customers. If you would like to get early access to this endpoint, please reach out to [Fireblocks Support](https://support.fireblocks.io/hc/en-us/requests/new?ticket_form_id=36000337220)   - This API call is subject to [rate limits](https://developers.fireblocks.com/reference/rate-limiting).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_asset_wallets(total_amount_larger_than, asset_id, before, after, limit, async_req = True)
        >>> result = thread.get()

        :param total_amount_larger_than: When specified, only asset wallets with total balance larger than this amount are returned.
        :type total_amount_larger_than: float
        :param asset_id: When specified, only asset wallets cross vault accounts that have this asset ID are returned.
        :type asset_id: str
        :param before: Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page.
        :type before: str
        :param after: Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page.
        :type after: str
        :param limit: The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000.
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PaginatedAssetWalletResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_asset_wallets_with_http_info(total_amount_larger_than, asset_id, before, after, limit, **kwargs)  # noqa: E501

    @validate_call
    def get_asset_wallets_with_http_info(self, total_amount_larger_than : Annotated[Optional[StrictFloat], Field(description="When specified, only asset wallets with total balance larger than this amount are returned.")] = None, asset_id : Annotated[Optional[StrictStr], Field(description="When specified, only asset wallets cross vault accounts that have this asset ID are returned.")] = None, before : Annotated[Optional[StrictStr], Field(description="Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page.")] = None, after : Annotated[Optional[StrictStr], Field(description="Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page.")] = None, limit : Annotated[Optional[confloat(ge=1000, le=1, strict=True)], Field(description="The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000.")] = None, **kwargs):  # noqa: E501
        """List asset wallets (Paginated)  # noqa: E501

        Gets all asset wallets at all of the vault accounts in your workspace. An asset wallet is an asset at a vault account. This method allows fast traversal of all account balances. **Note:**   - This API endpoint is in limited availability and available for selected customers. If you would like to get early access to this endpoint, please reach out to [Fireblocks Support](https://support.fireblocks.io/hc/en-us/requests/new?ticket_form_id=36000337220)   - This API call is subject to [rate limits](https://developers.fireblocks.com/reference/rate-limiting).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.get_asset_wallets_with_http_info(total_amount_larger_than, asset_id, before, after, limit, async_req=True)
        >>> result = thread.get()

        :param total_amount_larger_than: When specified, only asset wallets with total balance larger than this amount are returned.
        :type total_amount_larger_than: float
        :param asset_id: When specified, only asset wallets cross vault accounts that have this asset ID are returned.
        :type asset_id: str
        :param before: Fetches the next paginated response before this element. This element is a cursor and is returned at the response of the previous page.
        :type before: str
        :param after: Fetches the next paginated response after this element. This element is a cursor and is returned at the response of the previous page.
        :type after: str
        :param limit: The maximum number of asset wallets in a single response. The default is 200 and the maximum is 1000.
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PaginatedAssetWalletResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'total_amount_larger_than',
            'asset_id',
            'before',
            'after',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_asset_wallets" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('total_amount_larger_than') is not None:  # noqa: E501
            _query_params.append(('totalAmountLargerThan', _params['total_amount_larger_than']))

        if _params.get('asset_id') is not None:  # noqa: E501
            _query_params.append(('assetId', _params['asset_id']))

        if _params.get('before') is not None:  # noqa: E501
            _query_params.append(('before', _params['before']))

        if _params.get('after') is not None:  # noqa: E501
            _query_params.append(('after', _params['after']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "PaginatedAssetWalletResponse",
        }

        return self.api_client.call_api(
            '/vault/asset_wallets', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def get_max_spendable_amount(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account, or 'default' for the default vault account")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], manual_signging : Annotated[Optional[StrictBool], Field(description="False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device.")] = None, **kwargs) -> None:  # noqa: E501
        """Get the maximum spendable amount in a single transaction.  # noqa: E501

        Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_max_spendable_amount(vault_account_id, asset_id, manual_signging, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account, or 'default' for the default vault account (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param manual_signging: False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device.
        :type manual_signging: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.get_max_spendable_amount_with_http_info(vault_account_id, asset_id, manual_signging, **kwargs)  # noqa: E501

    @validate_call
    def get_max_spendable_amount_with_http_info(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account, or 'default' for the default vault account")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], manual_signging : Annotated[Optional[StrictBool], Field(description="False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device.")] = None, **kwargs):  # noqa: E501
        """Get the maximum spendable amount in a single transaction.  # noqa: E501

        Get the maximum amount of a particular asset that can be spent in a single transaction from a specified vault account (UTXO assets only, with a limitation on number of inputs embedded). Send several transactions if you want to spend more than the maximum spendable amount.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.get_max_spendable_amount_with_http_info(vault_account_id, asset_id, manual_signging, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account, or 'default' for the default vault account (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param manual_signging: False by default. The maximum number of inputs depends if the transaction will be signed by an automated co-signer server or on a mobile device.
        :type manual_signging: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'vault_account_id',
            'asset_id',
            'manual_signging'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_max_spendable_amount" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']

        if _params['asset_id']:
            _path_params['assetId'] = _params['asset_id']


        # process the query parameters
        _query_params = []
        if _params.get('manual_signging') is not None:  # noqa: E501
            _query_params.append(('manualSignging', _params['manual_signging']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/{assetId}/max_spendable_amount', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def get_paged_vault_accounts(self, name_prefix : Optional[StrictStr] = None, name_suffix : Optional[StrictStr] = None, min_amount_threshold : Optional[StrictFloat] = None, asset_id : Optional[StrictStr] = None, order_by : Optional[StrictStr] = None, before : Optional[StrictStr] = None, after : Optional[StrictStr] = None, limit : Optional[conint(strict=True, le=500, ge=1)] = None, **kwargs) -> VaultAccountsPagedResponse:  # noqa: E501
        """List vault acounts (Paginated)  # noqa: E501

        Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_paged_vault_accounts(name_prefix, name_suffix, min_amount_threshold, asset_id, order_by, before, after, limit, async_req = True)
        >>> result = thread.get()

        :param name_prefix:
        :type name_prefix: str
        :param name_suffix:
        :type name_suffix: str
        :param min_amount_threshold:
        :type min_amount_threshold: float
        :param asset_id:
        :type asset_id: str
        :param order_by:
        :type order_by: str
        :param before:
        :type before: str
        :param after:
        :type after: str
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: VaultAccountsPagedResponse
        """
        kwargs['_return_http_data_only'] = True
        return self.get_paged_vault_accounts_with_http_info(name_prefix, name_suffix, min_amount_threshold, asset_id, order_by, before, after, limit, **kwargs)  # noqa: E501

    @validate_call
    def get_paged_vault_accounts_with_http_info(self, name_prefix : Optional[StrictStr] = None, name_suffix : Optional[StrictStr] = None, min_amount_threshold : Optional[StrictFloat] = None, asset_id : Optional[StrictStr] = None, order_by : Optional[StrictStr] = None, before : Optional[StrictStr] = None, after : Optional[StrictStr] = None, limit : Optional[conint(strict=True, le=500, ge=1)] = None, **kwargs):  # noqa: E501
        """List vault acounts (Paginated)  # noqa: E501

        Gets all vault accounts in your workspace. This endpoint returns a limited amount of results with a quick response time.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.get_paged_vault_accounts_with_http_info(name_prefix, name_suffix, min_amount_threshold, asset_id, order_by, before, after, limit, async_req=True)
        >>> result = thread.get()

        :param name_prefix:
        :type name_prefix: str
        :param name_suffix:
        :type name_suffix: str
        :param min_amount_threshold:
        :type min_amount_threshold: float
        :param asset_id:
        :type asset_id: str
        :param order_by:
        :type order_by: str
        :param before:
        :type before: str
        :param after:
        :type after: str
        :param limit:
        :type limit: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(VaultAccountsPagedResponse, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'name_prefix',
            'name_suffix',
            'min_amount_threshold',
            'asset_id',
            'order_by',
            'before',
            'after',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_paged_vault_accounts" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('name_prefix') is not None:  # noqa: E501
            _query_params.append(('namePrefix', _params['name_prefix']))

        if _params.get('name_suffix') is not None:  # noqa: E501
            _query_params.append(('nameSuffix', _params['name_suffix']))

        if _params.get('min_amount_threshold') is not None:  # noqa: E501
            _query_params.append(('minAmountThreshold', _params['min_amount_threshold']))

        if _params.get('asset_id') is not None:  # noqa: E501
            _query_params.append(('assetId', _params['asset_id']))

        if _params.get('order_by') is not None:  # noqa: E501
            _query_params.append(('orderBy', _params['order_by']))

        if _params.get('before') is not None:  # noqa: E501
            _query_params.append(('before', _params['before']))

        if _params.get('after') is not None:  # noqa: E501
            _query_params.append(('after', _params['after']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "VaultAccountsPagedResponse",
        }

        return self.api_client.call_api(
            '/vault/accounts_paged', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def get_public_key_info(self, derivation_path : StrictStr, algorithm : StrictStr, compressed : Optional[StrictBool] = None, **kwargs) -> PublicKeyInformation:  # noqa: E501
        """Get the public key information  # noqa: E501

        Gets the public key information based on derivation path and signing algorithm.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_public_key_info(derivation_path, algorithm, compressed, async_req = True)
        >>> result = thread.get()

        :param derivation_path: (required)
        :type derivation_path: str
        :param algorithm: (required)
        :type algorithm: str
        :param compressed:
        :type compressed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PublicKeyInformation
        """
        kwargs['_return_http_data_only'] = True
        return self.get_public_key_info_with_http_info(derivation_path, algorithm, compressed, **kwargs)  # noqa: E501

    @validate_call
    def get_public_key_info_with_http_info(self, derivation_path : StrictStr, algorithm : StrictStr, compressed : Optional[StrictBool] = None, **kwargs):  # noqa: E501
        """Get the public key information  # noqa: E501

        Gets the public key information based on derivation path and signing algorithm.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.get_public_key_info_with_http_info(derivation_path, algorithm, compressed, async_req=True)
        >>> result = thread.get()

        :param derivation_path: (required)
        :type derivation_path: str
        :param algorithm: (required)
        :type algorithm: str
        :param compressed:
        :type compressed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PublicKeyInformation, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'derivation_path',
            'algorithm',
            'compressed'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_public_key_info" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('derivation_path') is not None:  # noqa: E501
            _query_params.append(('derivationPath', _params['derivation_path']))

        if _params.get('algorithm') is not None:  # noqa: E501
            _query_params.append(('algorithm', _params['algorithm']))

        if _params.get('compressed') is not None:  # noqa: E501
            _query_params.append(('compressed', _params['compressed']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "PublicKeyInformation",
        }

        return self.api_client.call_api(
            '/vault/public_key_info/', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def get_public_key_info_for_address(self, vault_account_id : StrictStr, asset_id : StrictStr, change : StrictFloat, address_index : StrictFloat, compressed : Optional[StrictBool] = None, **kwargs) -> PublicKeyInformation:  # noqa: E501
        """Get the public key for a vault account  # noqa: E501

        Gets the public key information for the vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_public_key_info_for_address(vault_account_id, asset_id, change, address_index, compressed, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: (required)
        :type vault_account_id: str
        :param asset_id: (required)
        :type asset_id: str
        :param change: (required)
        :type change: float
        :param address_index: (required)
        :type address_index: float
        :param compressed:
        :type compressed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: PublicKeyInformation
        """
        kwargs['_return_http_data_only'] = True
        return self.get_public_key_info_for_address_with_http_info(vault_account_id, asset_id, change, address_index, compressed, **kwargs)  # noqa: E501

    @validate_call
    def get_public_key_info_for_address_with_http_info(self, vault_account_id : StrictStr, asset_id : StrictStr, change : StrictFloat, address_index : StrictFloat, compressed : Optional[StrictBool] = None, **kwargs):  # noqa: E501
        """Get the public key for a vault account  # noqa: E501

        Gets the public key information for the vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.get_public_key_info_for_address_with_http_info(vault_account_id, asset_id, change, address_index, compressed, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: (required)
        :type vault_account_id: str
        :param asset_id: (required)
        :type asset_id: str
        :param change: (required)
        :type change: float
        :param address_index: (required)
        :type address_index: float
        :param compressed:
        :type compressed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(PublicKeyInformation, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'vault_account_id',
            'asset_id',
            'change',
            'address_index',
            'compressed'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_public_key_info_for_address" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']

        if _params['asset_id']:
            _path_params['assetId'] = _params['asset_id']

        if _params['change']:
            _path_params['change'] = _params['change']

        if _params['address_index']:
            _path_params['addressIndex'] = _params['address_index']


        # process the query parameters
        _query_params = []
        if _params.get('compressed') is not None:  # noqa: E501
            _query_params.append(('compressed', _params['compressed']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "PublicKeyInformation",
        }

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/{assetId}/{change}/{addressIndex}/public_key_info', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def get_vault_account_asset(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to return")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], **kwargs) -> VaultAsset:  # noqa: E501
        """Get the asset balance for a vault account  # noqa: E501

        Returns a wallet for a specific asset of a vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_vault_account_asset(vault_account_id, asset_id, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to return (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: VaultAsset
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vault_account_asset_with_http_info(vault_account_id, asset_id, **kwargs)  # noqa: E501

    @validate_call
    def get_vault_account_asset_with_http_info(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to return")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], **kwargs):  # noqa: E501
        """Get the asset balance for a vault account  # noqa: E501

        Returns a wallet for a specific asset of a vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.get_vault_account_asset_with_http_info(vault_account_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to return (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(VaultAsset, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'vault_account_id',
            'asset_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vault_account_asset" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']

        if _params['asset_id']:
            _path_params['assetId'] = _params['asset_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "VaultAsset",
        }

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/{assetId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def get_vault_account_asset_addresses(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to return")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], **kwargs) -> List[VaultWalletAddress]:  # noqa: E501
        """Get asset addresses  # noqa: E501

        Lists all addresses for specific asset of vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_vault_account_asset_addresses(vault_account_id, asset_id, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to return (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[VaultWalletAddress]
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vault_account_asset_addresses_with_http_info(vault_account_id, asset_id, **kwargs)  # noqa: E501

    @validate_call
    def get_vault_account_asset_addresses_with_http_info(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to return")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], **kwargs):  # noqa: E501
        """Get asset addresses  # noqa: E501

        Lists all addresses for specific asset of vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.get_vault_account_asset_addresses_with_http_info(vault_account_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to return (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[VaultWalletAddress], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'vault_account_id',
            'asset_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vault_account_asset_addresses" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']

        if _params['asset_id']:
            _path_params['assetId'] = _params['asset_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[VaultWalletAddress]",
        }

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/{assetId}/addresses', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def get_vault_account_asset_unspent_inputs(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], **kwargs) -> List[UnspentInputsResponse]:  # noqa: E501
        """Get UTXO unspent inputs information  # noqa: E501

        Returns unspent inputs information of an asset in a vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_vault_account_asset_unspent_inputs(vault_account_id, asset_id, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[UnspentInputsResponse]
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vault_account_asset_unspent_inputs_with_http_info(vault_account_id, asset_id, **kwargs)  # noqa: E501

    @validate_call
    def get_vault_account_asset_unspent_inputs_with_http_info(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], **kwargs):  # noqa: E501
        """Get UTXO unspent inputs information  # noqa: E501

        Returns unspent inputs information of an asset in a vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.get_vault_account_asset_unspent_inputs_with_http_info(vault_account_id, asset_id, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[UnspentInputsResponse], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'vault_account_id',
            'asset_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vault_account_asset_unspent_inputs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']

        if _params['asset_id']:
            _path_params['assetId'] = _params['asset_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[UnspentInputsResponse]",
        }

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/{assetId}/unspent_inputs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def get_vault_account_by_id(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to return type: string")], **kwargs) -> VaultAccount:  # noqa: E501
        """Find a vault account by ID  # noqa: E501

        Returns the requested vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_vault_account_by_id(vault_account_id, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to return type: string (required)
        :type vault_account_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: VaultAccount
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vault_account_by_id_with_http_info(vault_account_id, **kwargs)  # noqa: E501

    @validate_call
    def get_vault_account_by_id_with_http_info(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to return type: string")], **kwargs):  # noqa: E501
        """Find a vault account by ID  # noqa: E501

        Returns the requested vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.get_vault_account_by_id_with_http_info(vault_account_id, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to return type: string (required)
        :type vault_account_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(VaultAccount, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'vault_account_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vault_account_by_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "VaultAccount",
        }

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def get_vault_accounts(self, name_prefix : Optional[StrictStr] = None, name_suffix : Optional[StrictStr] = None, min_amount_threshold : Optional[StrictFloat] = None, asset_id : Optional[StrictStr] = None, **kwargs) -> List[VaultAccount]:  # noqa: E501
        """List vault accounts  # noqa: E501

        Gets all vault accounts in your workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_vault_accounts(name_prefix, name_suffix, min_amount_threshold, asset_id, async_req = True)
        >>> result = thread.get()

        :param name_prefix:
        :type name_prefix: str
        :param name_suffix:
        :type name_suffix: str
        :param min_amount_threshold:
        :type min_amount_threshold: float
        :param asset_id:
        :type asset_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[VaultAccount]
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vault_accounts_with_http_info(name_prefix, name_suffix, min_amount_threshold, asset_id, **kwargs)  # noqa: E501

    @validate_call
    def get_vault_accounts_with_http_info(self, name_prefix : Optional[StrictStr] = None, name_suffix : Optional[StrictStr] = None, min_amount_threshold : Optional[StrictFloat] = None, asset_id : Optional[StrictStr] = None, **kwargs):  # noqa: E501
        """List vault accounts  # noqa: E501

        Gets all vault accounts in your workspace.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.get_vault_accounts_with_http_info(name_prefix, name_suffix, min_amount_threshold, asset_id, async_req=True)
        >>> result = thread.get()

        :param name_prefix:
        :type name_prefix: str
        :param name_suffix:
        :type name_suffix: str
        :param min_amount_threshold:
        :type min_amount_threshold: float
        :param asset_id:
        :type asset_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[VaultAccount], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'name_prefix',
            'name_suffix',
            'min_amount_threshold',
            'asset_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vault_accounts" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('name_prefix') is not None:  # noqa: E501
            _query_params.append(('namePrefix', _params['name_prefix']))

        if _params.get('name_suffix') is not None:  # noqa: E501
            _query_params.append(('nameSuffix', _params['name_suffix']))

        if _params.get('min_amount_threshold') is not None:  # noqa: E501
            _query_params.append(('minAmountThreshold', _params['min_amount_threshold']))

        if _params.get('asset_id') is not None:  # noqa: E501
            _query_params.append(('assetId', _params['asset_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[VaultAccount]",
        }

        return self.api_client.call_api(
            '/vault/accounts', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def get_vault_asset_by_id(self, asset_id : StrictStr, **kwargs) -> VaultAsset:  # noqa: E501
        """Get vault balance by asset  # noqa: E501

        Gets the vault balance summary for an asset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_vault_asset_by_id(asset_id, async_req = True)
        >>> result = thread.get()

        :param asset_id: (required)
        :type asset_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: VaultAsset
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vault_asset_by_id_with_http_info(asset_id, **kwargs)  # noqa: E501

    @validate_call
    def get_vault_asset_by_id_with_http_info(self, asset_id : StrictStr, **kwargs):  # noqa: E501
        """Get vault balance by asset  # noqa: E501

        Gets the vault balance summary for an asset.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.get_vault_asset_by_id_with_http_info(asset_id, async_req=True)
        >>> result = thread.get()

        :param asset_id: (required)
        :type asset_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(VaultAsset, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'asset_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vault_asset_by_id" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['asset_id']:
            _path_params['assetId'] = _params['asset_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "VaultAsset",
        }

        return self.api_client.call_api(
            '/vault/assets/{assetId}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def get_vault_assets(self, account_name_prefix : Optional[StrictStr] = None, account_name_suffix : Optional[StrictStr] = None, **kwargs) -> List[VaultAsset]:  # noqa: E501
        """Get asset balance for chosen assets  # noqa: E501

        Gets the assets amount summary for all accounts or filtered accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_vault_assets(account_name_prefix, account_name_suffix, async_req = True)
        >>> result = thread.get()

        :param account_name_prefix:
        :type account_name_prefix: str
        :param account_name_suffix:
        :type account_name_suffix: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[VaultAsset]
        """
        kwargs['_return_http_data_only'] = True
        return self.get_vault_assets_with_http_info(account_name_prefix, account_name_suffix, **kwargs)  # noqa: E501

    @validate_call
    def get_vault_assets_with_http_info(self, account_name_prefix : Optional[StrictStr] = None, account_name_suffix : Optional[StrictStr] = None, **kwargs):  # noqa: E501
        """Get asset balance for chosen assets  # noqa: E501

        Gets the assets amount summary for all accounts or filtered accounts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.get_vault_assets_with_http_info(account_name_prefix, account_name_suffix, async_req=True)
        >>> result = thread.get()

        :param account_name_prefix:
        :type account_name_prefix: str
        :param account_name_suffix:
        :type account_name_suffix: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[VaultAsset], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'account_name_prefix',
            'account_name_suffix'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_vault_assets" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('account_name_prefix') is not None:  # noqa: E501
            _query_params.append(('accountNamePrefix', _params['account_name_prefix']))

        if _params.get('account_name_suffix') is not None:  # noqa: E501
            _query_params.append(('accountNameSuffix', _params['account_name_suffix']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[VaultAsset]",
        }

        return self.api_client.call_api(
            '/vault/assets', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def hide_vault_account(self, vault_account_id : Annotated[constr(strict=True), Field(..., description="The vault account to hide")], **kwargs) -> None:  # noqa: E501
        """Hide a vault account in the console  # noqa: E501

        Hides the requested vault account from the web console view.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.hide_vault_account(vault_account_id, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The vault account to hide (required)
        :type vault_account_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.hide_vault_account_with_http_info(vault_account_id, **kwargs)  # noqa: E501

    @validate_call
    def hide_vault_account_with_http_info(self, vault_account_id : Annotated[constr(strict=True), Field(..., description="The vault account to hide")], **kwargs):  # noqa: E501
        """Hide a vault account in the console  # noqa: E501

        Hides the requested vault account from the web console view.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.hide_vault_account_with_http_info(vault_account_id, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The vault account to hide (required)
        :type vault_account_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'vault_account_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hide_vault_account" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/hide', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def set_auto_fuel_for_vault_account(self, vault_account_id : Annotated[constr(strict=True), Field(..., description="The vault account ID")], set_auto_fuel_for_vault_account_request : SetAutoFuelForVaultAccountRequest, **kwargs) -> None:  # noqa: E501
        """Turn autofueling on or off  # noqa: E501

        Sets the autofueling property of the vault account to enabled or disabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.set_auto_fuel_for_vault_account(vault_account_id, set_auto_fuel_for_vault_account_request, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The vault account ID (required)
        :type vault_account_id: str
        :param set_auto_fuel_for_vault_account_request: (required)
        :type set_auto_fuel_for_vault_account_request: SetAutoFuelForVaultAccountRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.set_auto_fuel_for_vault_account_with_http_info(vault_account_id, set_auto_fuel_for_vault_account_request, **kwargs)  # noqa: E501

    @validate_call
    def set_auto_fuel_for_vault_account_with_http_info(self, vault_account_id : Annotated[constr(strict=True), Field(..., description="The vault account ID")], set_auto_fuel_for_vault_account_request : SetAutoFuelForVaultAccountRequest, **kwargs):  # noqa: E501
        """Turn autofueling on or off  # noqa: E501

        Sets the autofueling property of the vault account to enabled or disabled.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.set_auto_fuel_for_vault_account_with_http_info(vault_account_id, set_auto_fuel_for_vault_account_request, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The vault account ID (required)
        :type vault_account_id: str
        :param set_auto_fuel_for_vault_account_request: (required)
        :type set_auto_fuel_for_vault_account_request: SetAutoFuelForVaultAccountRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'vault_account_id',
            'set_auto_fuel_for_vault_account_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_auto_fuel_for_vault_account" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['set_auto_fuel_for_vault_account_request']:
            _body_params = _params['set_auto_fuel_for_vault_account_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/set_auto_fuel', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def set_customer_ref_id_for_vault_account(self, vault_account_id : Annotated[constr(strict=True), Field(..., description="The vault account ID")], set_customer_ref_id_for_vault_account_request : SetCustomerRefIdForVaultAccountRequest, **kwargs) -> None:  # noqa: E501
        """Set an AML/KYT customer reference ID for a vault account  # noqa: E501

        Assigns an AML/KYT customer reference ID for the vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.set_customer_ref_id_for_vault_account(vault_account_id, set_customer_ref_id_for_vault_account_request, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The vault account ID (required)
        :type vault_account_id: str
        :param set_customer_ref_id_for_vault_account_request: (required)
        :type set_customer_ref_id_for_vault_account_request: SetCustomerRefIdForVaultAccountRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.set_customer_ref_id_for_vault_account_with_http_info(vault_account_id, set_customer_ref_id_for_vault_account_request, **kwargs)  # noqa: E501

    @validate_call
    def set_customer_ref_id_for_vault_account_with_http_info(self, vault_account_id : Annotated[constr(strict=True), Field(..., description="The vault account ID")], set_customer_ref_id_for_vault_account_request : SetCustomerRefIdForVaultAccountRequest, **kwargs):  # noqa: E501
        """Set an AML/KYT customer reference ID for a vault account  # noqa: E501

        Assigns an AML/KYT customer reference ID for the vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.set_customer_ref_id_for_vault_account_with_http_info(vault_account_id, set_customer_ref_id_for_vault_account_request, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The vault account ID (required)
        :type vault_account_id: str
        :param set_customer_ref_id_for_vault_account_request: (required)
        :type set_customer_ref_id_for_vault_account_request: SetCustomerRefIdForVaultAccountRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'vault_account_id',
            'set_customer_ref_id_for_vault_account_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_customer_ref_id_for_vault_account" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['set_customer_ref_id_for_vault_account_request']:
            _body_params = _params['set_customer_ref_id_for_vault_account_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/set_customer_ref_id', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def set_customer_ref_id_for_vault_account_asset_address(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], address_id : Annotated[StrictStr, Field(..., description="The address for which to add a description. For XRP, use <address>:<tag>, for all other assets, use only the address")], set_customer_ref_id_for_vault_account_request : SetCustomerRefIdForVaultAccountRequest, **kwargs) -> None:  # noqa: E501
        """Assign AML customer reference ID  # noqa: E501

        Sets an AML/KYT customer reference ID for a specific address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.set_customer_ref_id_for_vault_account_asset_address(vault_account_id, asset_id, address_id, set_customer_ref_id_for_vault_account_request, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param address_id: The address for which to add a description. For XRP, use <address>:<tag>, for all other assets, use only the address (required)
        :type address_id: str
        :param set_customer_ref_id_for_vault_account_request: (required)
        :type set_customer_ref_id_for_vault_account_request: SetCustomerRefIdForVaultAccountRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.set_customer_ref_id_for_vault_account_asset_address_with_http_info(vault_account_id, asset_id, address_id, set_customer_ref_id_for_vault_account_request, **kwargs)  # noqa: E501

    @validate_call
    def set_customer_ref_id_for_vault_account_asset_address_with_http_info(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], address_id : Annotated[StrictStr, Field(..., description="The address for which to add a description. For XRP, use <address>:<tag>, for all other assets, use only the address")], set_customer_ref_id_for_vault_account_request : SetCustomerRefIdForVaultAccountRequest, **kwargs):  # noqa: E501
        """Assign AML customer reference ID  # noqa: E501

        Sets an AML/KYT customer reference ID for a specific address.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.set_customer_ref_id_for_vault_account_asset_address_with_http_info(vault_account_id, asset_id, address_id, set_customer_ref_id_for_vault_account_request, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param address_id: The address for which to add a description. For XRP, use <address>:<tag>, for all other assets, use only the address (required)
        :type address_id: str
        :param set_customer_ref_id_for_vault_account_request: (required)
        :type set_customer_ref_id_for_vault_account_request: SetCustomerRefIdForVaultAccountRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'vault_account_id',
            'asset_id',
            'address_id',
            'set_customer_ref_id_for_vault_account_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_customer_ref_id_for_vault_account_asset_address" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']

        if _params['asset_id']:
            _path_params['assetId'] = _params['asset_id']

        if _params['address_id']:
            _path_params['addressId'] = _params['address_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['set_customer_ref_id_for_vault_account_request']:
            _body_params = _params['set_customer_ref_id_for_vault_account_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}/set_customer_ref_id', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def unhide_vault_account(self, vault_account_id : Annotated[constr(strict=True), Field(..., description="The vault account to unhide")], **kwargs) -> None:  # noqa: E501
        """Unhide a vault account in the console  # noqa: E501

        Makes a hidden vault account visible in web console view.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.unhide_vault_account(vault_account_id, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The vault account to unhide (required)
        :type vault_account_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.unhide_vault_account_with_http_info(vault_account_id, **kwargs)  # noqa: E501

    @validate_call
    def unhide_vault_account_with_http_info(self, vault_account_id : Annotated[constr(strict=True), Field(..., description="The vault account to unhide")], **kwargs):  # noqa: E501
        """Unhide a vault account in the console  # noqa: E501

        Makes a hidden vault account visible in web console view.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.unhide_vault_account_with_http_info(vault_account_id, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The vault account to unhide (required)
        :type vault_account_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'vault_account_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method unhide_vault_account" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/unhide', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def update_vault_account(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to edit")], update_vault_account_request : UpdateVaultAccountRequest, **kwargs) -> None:  # noqa: E501
        """Rename a vault account  # noqa: E501

        Renames the requested vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_vault_account(vault_account_id, update_vault_account_request, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to edit (required)
        :type vault_account_id: str
        :param update_vault_account_request: (required)
        :type update_vault_account_request: UpdateVaultAccountRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.update_vault_account_with_http_info(vault_account_id, update_vault_account_request, **kwargs)  # noqa: E501

    @validate_call
    def update_vault_account_with_http_info(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to edit")], update_vault_account_request : UpdateVaultAccountRequest, **kwargs):  # noqa: E501
        """Rename a vault account  # noqa: E501

        Renames the requested vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.update_vault_account_with_http_info(vault_account_id, update_vault_account_request, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to edit (required)
        :type vault_account_id: str
        :param update_vault_account_request: (required)
        :type update_vault_account_request: UpdateVaultAccountRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'vault_account_id',
            'update_vault_account_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vault_account" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['update_vault_account_request']:
            _body_params = _params['update_vault_account_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def update_vault_account_asset_address(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], address_id : Annotated[StrictStr, Field(..., description="The address for which to add a description. For XRP, use <address>:<tag>, for all other assets, use only the address")], update_vault_account_asset_address_request : Optional[UpdateVaultAccountAssetAddressRequest] = None, **kwargs) -> None:  # noqa: E501
        """Update address description  # noqa: E501

        Updates the description of an existing address of an asset in a vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_vault_account_asset_address(vault_account_id, asset_id, address_id, update_vault_account_asset_address_request, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param address_id: The address for which to add a description. For XRP, use <address>:<tag>, for all other assets, use only the address (required)
        :type address_id: str
        :param update_vault_account_asset_address_request:
        :type update_vault_account_asset_address_request: UpdateVaultAccountAssetAddressRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """
        kwargs['_return_http_data_only'] = True
        return self.update_vault_account_asset_address_with_http_info(vault_account_id, asset_id, address_id, update_vault_account_asset_address_request, **kwargs)  # noqa: E501

    @validate_call
    def update_vault_account_asset_address_with_http_info(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], address_id : Annotated[StrictStr, Field(..., description="The address for which to add a description. For XRP, use <address>:<tag>, for all other assets, use only the address")], update_vault_account_asset_address_request : Optional[UpdateVaultAccountAssetAddressRequest] = None, **kwargs):  # noqa: E501
        """Update address description  # noqa: E501

        Updates the description of an existing address of an asset in a vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.update_vault_account_asset_address_with_http_info(vault_account_id, asset_id, address_id, update_vault_account_asset_address_request, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param address_id: The address for which to add a description. For XRP, use <address>:<tag>, for all other assets, use only the address (required)
        :type address_id: str
        :param update_vault_account_asset_address_request:
        :type update_vault_account_asset_address_request: UpdateVaultAccountAssetAddressRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: None
        """

        _params = locals()

        _all_params = [
            'vault_account_id',
            'asset_id',
            'address_id',
            'update_vault_account_asset_address_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vault_account_asset_address" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']

        if _params['asset_id']:
            _path_params['assetId'] = _params['asset_id']

        if _params['address_id']:
            _path_params['addressId'] = _params['address_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['update_vault_account_asset_address_request']:
            _body_params = _params['update_vault_account_asset_address_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {}

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/{assetId}/addresses/{addressId}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))

    @validate_call
    def update_vault_account_asset_balance(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to return")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], body : Optional[Dict[str, Any]] = None, **kwargs) -> VaultAsset:  # noqa: E501
        """Refresh asset balance data  # noqa: E501

        Updates the balance of a specific asset in a vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_vault_account_asset_balance(vault_account_id, asset_id, body, async_req = True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to return (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: VaultAsset
        """
        kwargs['_return_http_data_only'] = True
        return self.update_vault_account_asset_balance_with_http_info(vault_account_id, asset_id, body, **kwargs)  # noqa: E501

    @validate_call
    def update_vault_account_asset_balance_with_http_info(self, vault_account_id : Annotated[StrictStr, Field(..., description="The ID of the vault account to return")], asset_id : Annotated[StrictStr, Field(..., description="The ID of the asset")], body : Optional[Dict[str, Any]] = None, **kwargs):  # noqa: E501
        """Refresh asset balance data  # noqa: E501

        Updates the balance of a specific asset in a vault account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req = True

        >>> thread = api.update_vault_account_asset_balance_with_http_info(vault_account_id, asset_id, body, async_req=True)
        >>> result = thread.get()

        :param vault_account_id: The ID of the vault account to return (required)
        :type vault_account_id: str
        :param asset_id: The ID of the asset (required)
        :type asset_id: str
        :param body:
        :type body: object
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _return_http_data_only: response data without head status code
                                       and headers
        :type _return_http_data_only: bool, optional
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :type _preload_content: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(VaultAsset, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'vault_account_id',
            'asset_id',
            'body'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_vault_account_asset_balance" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['vault_account_id']:
            _path_params['vaultAccountId'] = _params['vault_account_id']

        if _params['asset_id']:
            _path_params['assetId'] = _params['asset_id']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['body']:
            _body_params = _params['body']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*', 'application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "VaultAsset",
        }

        return self.api_client.call_api(
            '/vault/accounts/{vaultAccountId}/{assetId}/balance', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body = _body_params,
            post_params=_form_params,
            files = _files,
            response_types_map = _response_types_map,
            auth_settings = _auth_settings,
            async_req = _params.get('async_req'),
            _return_http_data_only = _params.get('_return_http_data_only'),  # noqa: E501
            _preload_content = _params.get('_preload_content', True),
            _request_timeout = _params.get('_request_timeout'),
            collection_formats = _collection_formats,
            _request_auth = _params.get('_request_auth'))
